export default [
    { label: 'apply', type: 'Function' },
    { label: 'defun', type: 'Macro' },
    { label: 'fdefinition', type: 'Accessor' },
    { label: 'fboundp', type: 'Function' },
    { label: 'fmakunbound', type: 'Function' },
    { label: 'flet', type: 'Special Operator' },
    { label: 'labels', type: 'Special Operator' },
    { label: 'macrolet', type: 'Special Operator' },
    { label: 'funcall', type: 'Function' },
    { label: 'function', type: 'Special Operator' },
    { label: 'function-lambda-expression', type: 'Function' },
    { label: 'functionp', type: 'Function' },
    { label: 'compiled-function-p', type: 'Function' },
    { label: 'call-arguments-limit', type: 'Constant Variable' },
    { label: 'lambda-list-keywords', type: 'Constant Variable' },
    { label: 'lambda-parameters-limit', type: 'Constant Variable' },
    { label: 'defconstant', type: 'Macro' },
    { label: 'defparameter', type: 'Macro' },
    { label: 'defvar', type: 'Macro' },
    { label: 'destructuring-bind', type: 'Macro' },
    { label: 'let', type: 'Special Operator' },
    { label: 'let*', type: 'Special Operator' },
    { label: 'progv', type: 'Special Operator' },
    { label: 'setq', type: 'Special Form' },
    { label: 'psetq', type: 'Macro' },
    { label: 'block', type: 'Special Operator' },
    { label: 'catch', type: 'Special Operator' },
    { label: 'go', type: 'Special Operator' },
    { label: 'return-from', type: 'Special Operator' },
    { label: 'return', type: 'Macro' },
    { label: 'tagbody', type: 'Special Operator' },
    { label: 'throw', type: 'Special Operator' },
    { label: 'unwind-protect', type: 'Special Operator' },
    { label: 'nil', type: 'Constant Variable' },
    { label: 'not', type: 'Function' },
    { label: 't', type: 'Constant Variable' },
    { label: 'eq', type: 'Function' },
    { label: 'eql', type: 'Function' },
    { label: 'equal', type: 'Function' },
    { label: 'equalp', type: 'Function' },
    { label: 'identity', type: 'Function' },
    { label: 'complement', type: 'Function' },
    { label: 'constantly', type: 'Function' },
    { label: 'every', type: 'Function' },
    { label: 'some', type: 'Function' },
    { label: 'notevery', type: 'Function' },
    { label: 'notany', type: 'Function' },
    { label: 'and', type: 'Macro' },
    { label: 'cond', type: 'Macro' },
    { label: 'if', type: 'Special Operator' },
    { label: 'or', type: 'Macro' },
    { label: 'when', type: 'Macro' },
    { label: 'unless', type: 'Macro' },
    { label: 'case', type: 'Macro' },
    { label: 'ccase', type: 'Macro' },
    { label: 'ecase', type: 'Macro' },
    { label: 'typecase', type: 'Macro' },
    { label: 'ctypecase', type: 'Macro' },
    { label: 'etypecase', type: 'Macro' },
    { label: 'multiple-value-bind', type: 'Macro' },
    { label: 'multiple-value-call', type: 'Special Operator' },
    { label: 'multiple-value-list', type: 'Macro' },
    { label: 'multiple-value-prog1', type: 'Special Operator' },
    { label: 'multiple-value-setq', type: 'Macro' },
    { label: 'values', type: 'Accessor' },
    { label: 'values-list', type: 'Function' },
    { label: 'multiple-values-limit', type: 'Constant Variable' },
    { label: 'nth-value', type: 'Macro' },
    { label: 'prog', type: 'Macro' },
    { label: 'prog*', type: 'Macro' },
    { label: 'prog1', type: 'Macro' },
    { label: 'prog2', type: 'Macro' },
    { label: 'progn', type: 'Special Operator' },
    { label: 'define-modify-macro', type: 'Macro' },
    { label: 'defsetf', type: 'Macro' },
    { label: 'define-setf-expander', type: 'Macro' },
    { label: 'get-setf-expansion', type: 'Function' },
    { label: 'setf', type: 'Macro' },
    { label: 'psetf', type: 'Macro' },
    { label: 'shiftf', type: 'Macro' },
    { label: 'rotatef', type: 'Macro' },
    { label: 'control-error', type: 'Condition Type' },
    { label: 'program-error', type: 'Condition Type' },
    { label: 'undefined-function', type: 'Condition Type' },
];
